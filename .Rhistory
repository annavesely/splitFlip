o <- matrix(0, ncol=2, nrow=2)
colnames(o) <- c("nRej", "FWER")
rownames(o) <- c("old", "new")
for(seed in seq(nSim)){
res <- splitFlip::simData(prop=prop, m=m, n=n, rho=rho, type="toeplitz", SNR=SNR, seed=seed)
active <- res$active
inactive <- setdiff(seq(m),active)
target <- 2*length(active)
G <- splitFlip(res$X, res$Y, exact=TRUE, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=seed)
o[1,] <- o[1,] + analysisG(G, alpha, inactive)
G <- splitFlip_new(res$X, res$Y, exact=TRUE, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=seed)
o[2,] <- o[2,] + analysisG(G, alpha, inactive)
}
o <- o/nSim
return(o)
}
# 17 seconds
o <- get_comparison(n=10)
# 17 seconds
system.time(o <- get_comparison(n=10))
o
get_comparison <- function(m=20, prop=0.1, n=10, alpha=0.1, rho=0.5, SNR=5, nSim=100){
o <- matrix(0, ncol=2, nrow=2)
colnames(o) <- c("nRej", "FWER")
rownames(o) <- c("old", "new")
for(seed in seq(nSim)){
res <- splitFlip::simData(prop=prop, m=m, n=n, rho=rho, type="toeplitz", SNR=SNR, seed=seed)
active <- res$active
inactive <- setdiff(seq(m),active)
target <- 2*length(active)
G <- splitFlip(res$X, res$Y, exact=TRUE, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=seed)
o[1,] <- o[1,] + analysisG(G, alpha, inactive)
G <- splitFlip_new(res$X, res$Y, exact=TRUE, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=seed)
o[2,] <- o[2,] + analysisG(G, alpha, inactive)
}
o <- o/nSim
return(o)
}
# 17 seconds
system.time(o <- get_comparison(n=10))
o
system.time(o <- get_comparison(n=20, nSim=10))
o
get_comparison <- function(m=20, prop=0.1, n=10, alpha=0.1, rho=0.5, SNR=5, nSim=100){
o <- matrix(0, ncol=2, nrow=2)
colnames(o) <- c("nRej", "FWER")
rownames(o) <- c("old", "new")
for(seed in seq(nSim)){
res <- splitFlip::simData(prop=prop, m=m, n=n, rho=rho, type="toeplitz", SNR=SNR, seed=seed)
active <- res$active
inactive <- setdiff(seq(m),active)
target <- 2*length(active)
#G <- splitFlip(res$X, res$Y, exact=TRUE, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=seed)
#o[1,] <- o[1,] + analysisG(G, alpha, inactive)
G <- splitFlip_new(res$X, res$Y, exact=TRUE, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=seed)
o[2,] <- o[2,] + analysisG(G, alpha, inactive)
}
o <- o/nSim
return(o)
}
system.time(o <- get_comparison(n=20, nSim=10))
o
system.time(o <- get_comparison(n=40, nSim=10))
o
37*10/60
system.time(o <- get_comparison(n=40, nSim=100))
o
system.time(o <- get_comparison(n=20, nSim=100))
o
system.time(o <- get_comparison(n=20, nSim=200))
o
system.time(o <- get_comparison(n=40, nSim=500))
o
0.1 + 2*sqrt(0.1*0.9/500)
X <- rnorm(10)
X <- matrix(rnorm(15), ncol=3)
round(X)
Y <- rnorm(5)
cov(X,Y)
cov(X[,1],Y)
cov(X[,2],Y)
cov(X[,3],Y)
cor(X,Y)
cor(X[,1],Y)
cor(X[,2],Y)
cor(X[,3],Y)
?cor
require(splitFlip)
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
simData0 <- function(prop, m, n, rho=0, type="equicorr", incrBeta=FALSE, SNR=1, seed=NULL){
if(!is.numeric(prop) || !is.finite(prop)){stop("prop must be a number in [0,1]")}
if(prop < 0 || prop > 1){stop("prop must be a number in [0,1]")}
# check on m and n
if(!is.numeric(m) || !is.finite(m) || round(m) <= 0){stop("m must be a positive integer")}
if(!is.numeric(n) || !is.finite(n) || round(n) <= 0){stop("n must be a positive integer")}
m <- round(m)
n <- round(n)
# check on rho, type and SNR
if(!is.numeric(rho) || !is.finite(rho) || rho < -1 || rho > 1){stop("rho must be a number in [-1,1]")}
type <- match.arg(tolower(type), c("equicorr", "toeplitz"))
if(!is.numeric(SNR) || !is.finite(SNR) || SNR <= 0){stop("SNR must be a postive number")}
# check on seed
if(!is.null(seed)){if(!is.numeric(seed) || !is.finite(seed)){stop("seed must be a finite integer")}}
else{seed <- sample(seq(10^9), 1)}
set.seed(round(seed))
if(type == "equicorr"){
X <- sqrt(1-rho) * matrix(rnorm(m*n), ncol=m) + sqrt(rho) * matrix(rep(rnorm(n), m), ncol=m)
}else{
r <- rho^(0:(m-1))
Sigma <- stats::toeplitz(r)
X <- mvtnorm::rmvnorm(n, sigma=Sigma)
}
m1 <- ceiling(m * prop)
active <- seq(m1)
beta <- rep(0,m)
beta[active] <- ifelse(incrBeta, active, rep(1,m1))
mu <- X %*% beta
mu_norm <- sqrt(t(mu) %*% mu)
serr <- mu_norm/SNR # sd of the error term
Y <- rnorm(n=n, mean=mu, sd=serr)
out <- list("X"=X, "Y"=Y, "active"=active)
return(out)
}
res <- simData0(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
res
simData0 <- function(prop, m, n, rho=0, type="equicorr", incrBeta=FALSE, SNR=1, seed=NULL){
if(!is.numeric(prop) || !is.finite(prop)){stop("prop must be a number in [0,1]")}
if(prop < 0 || prop > 1){stop("prop must be a number in [0,1]")}
# check on m and n
if(!is.numeric(m) || !is.finite(m) || round(m) <= 0){stop("m must be a positive integer")}
if(!is.numeric(n) || !is.finite(n) || round(n) <= 0){stop("n must be a positive integer")}
m <- round(m)
n <- round(n)
# check on rho, type and SNR
if(!is.numeric(rho) || !is.finite(rho) || rho < -1 || rho > 1){stop("rho must be a number in [-1,1]")}
type <- match.arg(tolower(type), c("equicorr", "toeplitz"))
if(!is.numeric(SNR) || !is.finite(SNR) || SNR <= 0){stop("SNR must be a postive number")}
# check on seed
if(!is.null(seed)){if(!is.numeric(seed) || !is.finite(seed)){stop("seed must be a finite integer")}}
else{seed <- sample(seq(10^9), 1)}
set.seed(round(seed))
if(type == "equicorr"){
X <- sqrt(1-rho) * matrix(rnorm(m*n), ncol=m) + sqrt(rho) * matrix(rep(rnorm(n), m), ncol=m)
}else{
r <- rho^(0:(m-1))
Sigma <- stats::toeplitz(r)
X <- mvtnorm::rmvnorm(n, sigma=Sigma)
}
m1 <- ceiling(m * prop)
active <- sample(seq(m), m1)
beta <- rep(0, m)
if(incrBeta){
beta[active] <- seq(m1)
}else{
beta[active] <- rep(1,m1)
}
active <- sort(active)
mu <- X %*% beta
mu_norm <- sqrt(t(mu) %*% mu)
serr <- mu_norm/SNR # sd of the error term
Y <- rnorm(n=n, mean=mu, sd=serr)
out <- list("X"=X, "Y"=Y, "active"=active)
return(out)
}
res <- simData0(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
res
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
target <- 2*length(active)
targetLasso(X, Y, target)
active
if(!is.matrix(X) || !is.numeric(X) || !all(is.finite(X))){stop("X must be a matrix of finite numbers")}
if(!is.vector(Y) || !is.numeric(Y) || !all(is.finite(Y))){stop("Y must be a vector of finite numbers")}
if(!(nrow(X)==length(Y))){stop("Dimensions of X and Y are incompatible")}
if(is.null(target)){target <- nrow(X)}
if(!is.numeric(target) || !is.finite(target) || floor(target) <= 0){stop("target must be a positive integer")}
target <- floor(target)
dim(X)
dim(Y)
length(Y)
c <- cor(X,Y)
c
ncol(X)
sort(c, decreasing=FALSE)
sort(c, decreasing=TRUE)
order(c, decreasing=TRUE)
which.max(c)
c <- abs(cor(X,Y))
which.max(c)
order(c, decreasing=TRUE)
c[11]
c[18]
c[3]
sel <- order(c)[seq(target)]
sel
sel <- order(c, decreasing=FALSE)[seq(target)]
sel
sel <- order(c, decreasing=TRUE)[seq(target)]
sel
active
order(c, decreasing=TRUE)
targetLasso(X, Y, target)
sel
c <- cor(X,Y)
order(c, decreasing=TRUE)[seq(target)]
c
devtools::document()
?targetCor
devtools::document()
?targetCor
devtools::document()
library(splitFlip)
?simData
devtools::document()
?simData
devtools::document()
?simData
es <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
# matrix of standardized scores for all variables (columns) and random sign flips (rows)
# using the approximate method with Lasso selection
G <- splitFlip(X, Y, target=target, seed=42)
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
target <- 2*length(active)
# matrix of standardized scores for all variables (columns) and random sign flips (rows)
# using the approximate method with Lasso selection
G <- splitFlip(X, Y, target=target, seed=42)
maxT(G, alpha=0.1)
?splitFlip
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
# matrix of standardized scores for all variables (columns) and random sign flips (rows)
# using the approximate method with Lasso selection
G1 <- splitFlip(X, Y, target=target, seed=42)
# maxT algorithm
maxT(G1, alpha=0.1)
G2 <- splitFlip(X, Y, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
# maxT algorithm
maxT(G2, alpha=0.1)
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=10, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
# matrix of standardized scores for all variables (columns) and random sign flips (rows)
# using the approximate method with Lasso selection
G1 <- splitFlip(X, Y, target=target, seed=42)
# maxT algorithm
maxT(G1, alpha=0.1)
G2 <- splitFlip(X, Y, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
# maxT algorithm
maxT(G2, alpha=0.1)
active
devtools::document()
library(splitFlip)
devtools::document()
?simData
?splitFlip
library(splitFlip)
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
library(splitFlip)
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variable
active
target <- 2*length(active)
G1 <- splitFlip(X, Y, target=target, seed=42)
maxT(G1, alpha=0.1)
G2 <- splitFlip(X, Y, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
# maxT algorithm
maxT(G2, alpha=0.1)
0.1*20
require(splitFlip)
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
if(!is.matrix(X) || !is.numeric(X) || !all(is.finite(X))){stop("X must be a matrix of finite numbers")}
if(!is.vector(Y) || !is.numeric(Y) || !all(is.finite(Y))){stop("Y must be a vector of finite numbers")}
if(!(nrow(X)==length(Y))){stop("Dimensions of X and Y are incompatible")}
nfolds = 10
grouped = TRUE
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
require(splitFlip)
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
target <- 2*length(active)
nfolds = 10
grouped = TRUE
fit <- glmnet::cv.glmnet(X, Y, nfolds = nfolds, grouped = grouped)
grouped <- (nrow(X) > 3 * nfolds)
fit <- glmnet::cv.glmnet(X, Y, nfolds = nfolds, grouped = grouped)
fit
coef(fit)
predict(fit)
predict(fit, type="nonzero")
lasso.cv(X,Y)
hdi::lasso.cv(X,Y)
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=20, seed=42)
X <- res$X
Y <- res$Y
grouped <- (nrow(X) > 3 * nfolds)
fit <- glmnet::cv.glmnet(X, Y, nfolds = nfolds, grouped = grouped)
L <- length(fit$lambda[fit$df <= target])
sel <- predict(fit, type="nonzero")[[1]]
sel
predict(fit, type="nonzero")
res$active
Q <- 20
B <- 200
target <- NULL
cvLasso <- function(X, Y, nfolds = 10, grouped = NULL){
if(!is.matrix(X) || !is.numeric(X) || !all(is.finite(X))){stop("X must be a matrix of finite numbers")}
if(!is.vector(Y) || !is.numeric(Y) || !all(is.finite(Y))){stop("Y must be a vector of finite numbers")}
if(!(nrow(X)==length(Y))){stop("Dimensions of X and Y are incompatible")}
grouped <- (nrow(X) > 3 * nfolds)
fit <- glmnet::cv.glmnet(X, Y, nfolds = nfolds, grouped = grouped)
L <- length(fit$lambda[fit$df <= target])
sel <- predict(fit, type="nonzero")[[1]]
return(sel)
}
if(!is.matrix(X) || !is.numeric(X) || !all(is.finite(X))){stop("X must be a matrix of finite numbers")}
n <- nrow(X)
m <- ncol(X)
n0 <- floor(n/2)
if(!is.vector(Y) || !is.numeric(Y) || !all(is.finite(Y))){stop("Y must be a vector of finite numbers")}
if(!(length(Y)==n)){stop("Dimensions of X and Y are incompatible")}
if(is.null(target)){target <- n0}
if(!is.numeric(target) || !is.finite(target) || floor(target) <= 0 || floor(target) > n0){stop("target must be an integer between 1 and half the sample size")}
target <- floor(target)
target
n0
if(!is.numeric(Q) || !is.finite(Q) || round(Q) <= 0){stop("Q must be a positive integer")}
if(!is.numeric(B) || !is.finite(B) || round(B) <= 0){stop("B must be a positive integer")}
Q <- round(Q)
B <- round(B)
if(!is.null(seed)){if(!is.numeric(seed) || !is.finite(seed)){stop("seed must be a finite integer")}}
seed <- 1
if(!is.null(seed)){if(!is.numeric(seed) || !is.finite(seed)){stop("seed must be a finite integer")}}
else{seed <- sample(seq(10^9), 1)}
set.seed(round(seed))
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X
Y <- res$Y
target <- NULL
Q <- 10
cvLasso <- function(X, Y, nfolds = 10, grouped = NULL){
if(!is.matrix(X) || !is.numeric(X) || !all(is.finite(X))){stop("X must be a matrix of finite numbers")}
if(!is.vector(Y) || !is.numeric(Y) || !all(is.finite(Y))){stop("Y must be a vector of finite numbers")}
if(!(nrow(X)==length(Y))){stop("Dimensions of X and Y are incompatible")}
grouped <- (nrow(X) > 3 * nfolds)
fit <- glmnet::cv.glmnet(X, Y, nfolds = nfolds, grouped = grouped)
L <- length(fit$lambda[fit$df <= target])
sel <- predict(fit, type="nonzero")[[1]]
return(sel)
}
varSel <- cvLasso
varSelArgs <- list("nfolds"=10, "grouped"=FALSE)
if(is.null(seed)){seed <- sample(seq(10^9), 1)}
set.seed(round(seed))
m <- ncol(X)
n <- nrow(X)
seed <- 1
if(is.null(seed)){seed <- sample(seq(10^9), 1)}
set.seed(round(seed))
m <- ncol(X)
n <- nrow(X)
n0 <- floor(n/2)
obs <- vector(mode="list", length=Q)
vars <- vector(mode="list", length=Q)
q <- 1
# randomly split the data in 2 subsets
D1 <- sample(seq(n), n0) # first subset
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs))) # selected variables
cvLasso <- function(X, Y, target=NULL, nfolds = 10, grouped = NULL){
if(!is.matrix(X) || !is.numeric(X) || !all(is.finite(X))){stop("X must be a matrix of finite numbers")}
if(!is.vector(Y) || !is.numeric(Y) || !all(is.finite(Y))){stop("Y must be a vector of finite numbers")}
if(!(nrow(X)==length(Y))){stop("Dimensions of X and Y are incompatible")}
grouped <- (nrow(X) > 3 * nfolds)
fit <- glmnet::cv.glmnet(X, Y, nfolds = nfolds, grouped = grouped)
L <- length(fit$lambda[fit$df <= target])
sel <- predict(fit, type="nonzero")[[1]]
return(sel)
}
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs))) # selected variables
varSel <- cvLasso
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs))) # selected variables
V
X <- res$X
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
res <- simData(prop=0.6, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
res <- simData(prop=0.6, m=20, n=10, rho=0.5, type="toeplitz", SNR=16, seed=42)
X <- res$X
Y <- res$Y
Q <- 10
cvLasso <- function(X, Y, target=NULL, nfolds = 10, grouped = NULL){
if(!is.matrix(X) || !is.numeric(X) || !all(is.finite(X))){stop("X must be a matrix of finite numbers")}
if(!is.vector(Y) || !is.numeric(Y) || !all(is.finite(Y))){stop("Y must be a vector of finite numbers")}
if(!(nrow(X)==length(Y))){stop("Dimensions of X and Y are incompatible")}
grouped <- (nrow(X) > 3 * nfolds)
fit <- glmnet::cv.glmnet(X, Y, nfolds = nfolds, grouped = grouped)
L <- length(fit$lambda[fit$df <= target])
sel <- predict(fit, type="nonzero")[[1]]
return(sel)
}
varSel <- cvLasso
varSelArgs <- list("nfolds"=nfolds, "grouped"=grouped)
varSelArgs <- list("nfolds"=10, "grouped"=F)
if(is.null(seed)){seed <- sample(seq(10^9), 1)}
set.seed(round(seed))
m <- ncol(X)
seed <- 1
set.seed(round(seed))
m <- ncol(X)
n <- nrow(X)
n0 <- floor(n/2)
obs <- vector(mode="list", length=Q)
vars <- vector(mode="list", length=Q)
q <- 1
tryAgain <- TRUE
h <- 1
tryAgain
# randomly split the data in 2 subsets
D1 <- sample(seq(n), n0) # first subset
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs))) # selected variables
target <- NULL
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs))) # selected variables
V
# randomly split the data in 2 subsets
D1 <- sample(seq(n), n0) # first subset
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs))) # selected variables
V
varSel
res <- simData(prop=1, m=20, n=10, rho=0.5, type="toeplitz", SNR=16, seed=42)
X <- res$X
Y <- res$Y
cvLasso(X,Y)
# randomly split the data in 2 subsets
D1 <- sample(seq(n), n0) # first subset
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs))) # selected variables
V
cvLasso(X[D1,],Y[D1])
ii <- cvLasso(X[D1,],Y[D1])
length(ii)
res <- simData(prop=1, m=20, n=10, rho=0.5, type="toeplitz", SNR=20, seed=42)
X <- res$X
Y <- res$Y
cvLasso(X[D1,],Y[D1])
res <- simData(prop=1, m=20, n=20, rho=0.5, type="toeplitz", SNR=20, seed=42)
X <- res$X
Y <- res$Y
cvLasso(X[D1,],Y[D1])
res <- simData(prop=0.2, m=20, n=20, rho=0.5, type="toeplitz", SNR=20, seed=42)
X <- res$X
Y <- res$Y
cvLasso(X[D1,],Y[D1])
res <- simData(prop=0.5, m=20, n=20, rho=0.5, type="toeplitz", SNR=20, seed=42)
cvLasso(res$X[D1,],res$Y[D1])
res <- simData(prop=0.5, m=20, n=20, rho=0.5, type="toeplitz", SNR=30, seed=42)
cvLasso(res$X[D1,],res$Y[D1])
# randomly split the data in 2 subsets
D1 <- sample(seq(n), n0) # first subset
cvLasso(res$X[D1,],res$Y[D1])
# randomly split the data in 2 subsets
D1 <- sample(seq(n), n0) # first subset
cvLasso(res$X[D1,],res$Y[D1])
res <- simData(prop=0.5, m=20, n=100, rho=0.5, type="toeplitz", SNR=30, seed=42)
cvLasso(res$X[D1,],res$Y[D1])
res <- simData(prop=0.5, m=20, n=10, rho=0.5, type="toeplitz", SNR=30, seed=42)
cvLasso(res$X[D1,],res$Y[D1])
res <- simData(prop=0.5, m=20, n=10, rho=0.5, type="toeplitz", SNR=30, seed=42)
cvLasso(res$X[D1,],res$Y[D1])
res <- simData(prop=0.5, m=20, n=10, rho=0.5, type="toeplitz", SNR=30, seed=42)
rm(varSelArgs)
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs))) # selected variables
hdi::lasso.proj
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=20, seed=42)
X <- res$X
Y <- res$Y
if(!is.matrix(X) || !is.numeric(Y) || !all(is.finite(X))){stop("X must be a matrix of finite numbers")}
if(!is.vector(Y) || !is.numeric(Y) || !all(is.finite(Y))){stop("Y must be a vector of finite numbers")}
if(!(nrow(X)==length(Y))){stop("Dimensions of X and Y are incompatible")}
sel <- hdi::lasso.cv(X,Y)
sel
target <- 4
if(!is.numeric(target) || !is.finite(target) || floor(target) <= 0){stop("target must be a positive integer")}
target <- floor(target)
sel <- hdi::lasso.firstq(x,y,target)
sel <- hdi::lasso.firstq(X,Y,target)
sel
targetLasso
targetLasso(X,Y,target)
sel
