obs[[q]] <- setdiff(seq(n), D1)
vars[[q]] <- V
tryAgain <- FALSE
}else{
h <- h + 1
warning("Too large model selected in a sample-split")
if(h > maxRepeat){stop("More than maxRepeat=", maxRepeat, " sample splits resulted in too large models")}
}
}
}
vars
obs
set.seed(round(seed))
m <- ncol(X)
n <- nrow(X)
n0 <- floor(n/2)
obs <- vector(mode="list", length=Q)
vars <- vector(mode="list", length=Q)
obs
vars
q <- 1
tryAgain <- TRUE
h <- 1
while(tryAgain){
# randomly split the data in 2 subsets
D1 <- sample(seq(n), n0) # first subset
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1]), varSelArgs))) # selected variables
if(length(V) <= n0){
obs[[q]] <- setdiff(seq(n), D1)
vars[[q]] <- V
tryAgain <- FALSE
}else{
h <- h + 1
warning("Too large model selected in a sample-split")
if(h > maxRepeat){stop("More than maxRepeat=", maxRepeat, " sample splits resulted in too large models")}
}
}
vars
sel
obs
obs <- vector(mode="list", length=Q)
vars <- vector(mode="list", length=Q)
for(q in seq(Q)){
tryAgain <- TRUE
h <- 1
while(tryAgain){
# randomly split the data in 2 subsets
D1 <- sample(seq(n), n0) # first subset
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1]), varSelArgs))) # selected variables
if(length(V) <= n0){
obs[[q]] <- setdiff(seq(n), D1)
vars[[q]] <- V
tryAgain <- FALSE
}else{
h <- h + 1
warning("Too large model selected in a sample-split")
if(h > maxRepeat){stop("More than maxRepeat=", maxRepeat, " sample splits resulted in too large models")}
}
}
}
obs
vars
obs <- vector(mode="list", length=Q)
vars <- vector(mode="list", length=Q)
q <- 1
tryAgain <- TRUE
h <- 1
while(tryAgain){
# randomly split the data in 2 subsets
D1 <- sample(seq(n), n0) # first subset
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1]), varSelArgs))) # selected variables
if(length(V) <= n0){
obs[[q]] <- setdiff(seq(n), D1)
vars[[q]] <- V
tryAgain <- FALSE
}else{
h <- h + 1
warning("Too large model selected in a sample-split")
if(h > maxRepeat){stop("More than maxRepeat=", maxRepeat, " sample splits resulted in too large models")}
}
}
obs
vars
q <- 2
tryAgain <- TRUE
h <- 1
while(tryAgain){
# randomly split the data in 2 subsets
D1 <- sample(seq(n), n0) # first subset
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1]), varSelArgs))) # selected variables
if(length(V) <= n0){
obs[[q]] <- setdiff(seq(n), D1)
vars[[q]] <- V
tryAgain <- FALSE
}else{
h <- h + 1
warning("Too large model selected in a sample-split")
if(h > maxRepeat){stop("More than maxRepeat=", maxRepeat, " sample splits resulted in too large models")}
}
}
obs
vars
q <- 3
tryAgain <- TRUE
h <- 1
# randomly split the data in 2 subsets
D1 <- sample(seq(n), n0) # first subset
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1]), varSelArgs))) # selected variables
length(V) <= n0
obs[[q]] <- setdiff(seq(n), D1)
vars[[q]] <- V
obs
vars
V
q
1 %in% NULL
obs <- vector(mode="list", length=Q)
vars <- vector(mode="list", length=Q)
for(q in seq(Q)){
tryAgain <- TRUE
h <- 1
while(tryAgain){
# randomly split the data in 2 subsets
D1 <- sample(seq(n), n0) # first subset
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1]), varSelArgs))) # selected variables
if(length(V) <= n0){
obs[[q]] <- setdiff(seq(n), D1)
if(length(V) > 0){vars[[q]] <- V}
tryAgain <- FALSE
}else{
h <- h + 1
warning("Too large model selected in a sample-split")
if(h > maxRepeat){stop("More than maxRepeat=", maxRepeat, " sample splits resulted in too large models")}
}
}
}
obs
vars
obs <- vector(mode="list", length=Q)
vars <- vector(mode="list", length=Q)
for(q in seq(Q)){
tryAgain <- TRUE
h <- 1
while(tryAgain){
# randomly split the data in 2 subsets
D1 <- sample(seq(n), n0) # first subset
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1]), varSelArgs))) # selected variables
if(length(V) <= n0){
obs[[q]] <- setdiff(seq(n), D1)
if(length(V) > 0){vars[[q]] <- V}
tryAgain <- FALSE
}else{
h <- h + 1
warning("Too large model selected in a sample-split")
if(h > maxRepeat){stop("More than maxRepeat=", maxRepeat, " sample splits resulted in too large models")}
}
}
}
vars
obs
for(q in seq(Q)){
tryAgain <- TRUE
h <- 1
while(tryAgain){
# randomly split the data in 2 subsets
D1 <- sample(seq(n), n0) # first subset
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1]), varSelArgs))) # selected variables
if(length(V) <= n0){
obs[[q]] <- setdiff(seq(n), D1)
if(length(V) > 0){vars[[q]] <- V}
tryAgain <- FALSE
}else{
h <- h + 1
warning("Too large model selected in a sample-split")
if(h > maxRepeat){stop("More than maxRepeat=", maxRepeat, " sample splits resulted in too large models")}
}
}
}
obs
vars
V
devtools::document()
res <- simData(m1=2, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
varSel <- selLasso
devtools::document()
library(splitFlip)
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs))) # selected variables
res <- simData(m1=2, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
m <- ncol(X)
n <- nrow(X)
n0 <- floor(n/2)
# randomly split the data in 2 subsets
D1 <- sample(seq(n), n0) # first subset
varSel <- selLasso
target
varSelArgs <- NULL
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs))) # selected variables
V
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs))) # selected variables
V
target <- NULL
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs))) # selected variables
V
varSelArgs <- list("nfolds"=5)
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs))) # selected variables
V
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs))) # selected variables
V <- do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs)) # selected variables
V
varSelArgs <- list("nfolds"=20)
V <- do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs)) # selected variables
V
varSelArgs <- list("grouped"=TRUE)
V <- do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs)) # selected variables
hdi::multi.split()
?hdi::multi.split
getSplits(X, Y, Q=3, target=4, varSel=selLasso, varSelArgs=NULL, maxRepeat=20, seed=1)
library(splitFlip)
res <- simData(m1=2, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
getSplits(X, Y, Q=3, target=4, varSel=selLasso, varSelArgs=NULL, maxRepeat=20, seed=1)
splitFlip::getSplits(X, Y, Q=3, target=4, varSel=selLasso, varSelArgs=NULL, maxRepeat=20, seed=1)
getSplits <- function(X, Y, Q, target, varSel, varSelArgs, maxRepeat=20, seed){
if(is.null(seed)){seed <- sample(seq(10^9), 1)}
set.seed(round(seed))
m <- ncol(X)
n <- nrow(X)
n0 <- floor(n/2)
obs <- vector(mode="list", length=Q)
vars <- vector(mode="list", length=Q)
# signs <- matrix(0, ncol=m, nrow=Q)
for(q in seq(Q)){
tryAgain <- TRUE
h <- 1
while(tryAgain){
# randomly split the data in 2 subsets
D1 <- sample(seq(n), n0) # first subset
V <- do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs)) # selected variables
if(length(V) <= n0){
obs[[q]] <- setdiff(seq(n), D1)
if(length(V) > 0){vars[[q]] <- V}
tryAgain <- FALSE
}else{
h <- h + 1
warning("Too large model selected in a sample-split")
if(h > maxRepeat){stop("More than maxRepeat=", maxRepeat, " sample splits resulted in too large models")}
}
}
}
out <- list("obs"=obs, "vars"=vars)
return(out)
}
getSplits(X, Y, Q=3, target=4, varSel=selLasso, varSelArgs=NULL, maxRepeat=20, seed=1)
getSplits(X, Y, Q=3, target=NULL, varSel=selLasso, varSelArgs=NULL, maxRepeat=20, seed=1)
getSplits(X, Y, Q=3, target=NULL, varSel=selLasso, varSelArgs=NULL, maxRepeat=20, seed=2)
getSplits(X, Y, Q=3, target=NULL, varSel=selLasso, varSelArgs=list("grouped"=T), maxRepeat=20, seed=2)
getSplits(X, Y, Q=3, target=NULL, varSel=selOracle, varSelArgs=NULL, maxRepeat=20, seed=2)
getSplits(X, Y, Q=3, target=NULL, varSel=selOracle, varSelArgs=list("toSel"=active), maxRepeat=20, seed=2)
getSplits(X, Y, Q=3, target=4, varSel=selOracle, varSelArgs=list("toSel"=active), maxRepeat=20, seed=2)
getSplits(X, Y, Q=3, target=10, varSel=selOracle, varSelArgs=list("toSel"=active), maxRepeat=20, seed=2)
warnings()
Q=50
B=200
target=NULL
exact=FALSE
varSel=selLasso
varSelArgs=NULL
seed=NULL
if(!is.matrix(X) || !is.numeric(X) || !all(is.finite(X))){stop("X must be a matrix of finite numbers")}
n <- nrow(X)
m <- ncol(X)
n0 <- floor(n/2)
if(!is.vector(Y) || !is.numeric(Y) || !all(is.finite(Y))){stop("Y must be a vector of finite numbers")}
if(!(length(Y)==n)){stop("Dimensions of X and Y are incompatible")}
if(is.null(target)){target <- n0}
if(!is.numeric(target) || !is.finite(target) || floor(target) <= 0 || floor(target) > n0){stop("target must be an integer between 1 and half the sample size")}
target <- floor(target)
if(!is.numeric(Q) || !is.finite(Q) || round(Q) <= 0){stop("Q must be a positive integer")}
if(!is.numeric(B) || !is.finite(B) || round(B) <= 0){stop("B must be a positive integer")}
Q <- round(Q)
B <- round(B)
if(!is.null(seed)){if(!is.numeric(seed) || !is.finite(seed)){stop("seed must be a finite integer")}}
else{seed <- sample(seq(10^9), 1)}
set.seed(round(seed))
if(!is.null(seed)){if(!is.numeric(seed) || !is.finite(seed)){stop("seed must be a finite integer")}}
else{seed <- sample(seq(10^9), 1)}
# select observations and variables
sel <- getSplits(X, Y, Q, target, varSel, varSelArgs, seed)
# select observations and variables
sel <- getSplits(X, Y, Q, target, varSel, varSelArgs, maxRepeat, seed)
sel
# select observations and variables
sel <- getSplits(X, Y, Q, target, varSel, varSelArgs, maxRepeat, 2)
sel
# select observations and variables
sel <- getSplits(X, Y, Q, target, varSel, varSelArgs, maxRepeat, 2)
# select observations and variables
sel <- getSplits(X, Y, Q, target, varSel, varSelArgs, maxRepeat, 2)
sel
sel$vars[[1]]
sel$vars[[1]] <- NULL
sel$vars
# select observations and variables
sel <- getSplits(X, Y, Q, target, varSel, varSelArgs, maxRepeat, 2)
s <- vector(mode="list", length=Q)
s
s[[1:2]]
for(q in (2:50)){s[[q]] <- sel[[q]]}
sel
for(q in (2:50)){s[[q]] <- sel$vars[[q]]}
s
s[[1]]
sel$vars <- s
sel$vars
# maximum number of selected variables (useful if users add their own varSel function)
smax <- max(sapply(sel$vars, length))
if(smax > n0){stop("the number of selected variables should not exceed half the sample size")}
# create all flips
fl <- cbind(rep(1,n), replicate(B-1, 1-2*rbinom(n,1,0.5)))
# create matrix of standardized scores
G <- matrix(0, ncol=m, nrow=B)
jsplitFlip <- function(j, X, Y, sel, fl, exact){
n <- nrow(fl)
B <- ncol(fl)
Q <- length(sel$obs)
out <- rep(0,B) # scores for each flip
i <- 0 # times that j was selected
# APPROXIMATE METHOD
if(!exact){
R <- matrix(0, ncol=n, nrow=n)
# for each split, compute and sum the terms R=I-H
for(q in seq(Q)){
if(j %in% sel$vars[[q]]){
i <- i+1
R <- R + residualMatrix(j, X, sel$obs[[q]], setdiff(sel$vars[[q]],j))
}
}
if(i == 0){return(out)} # if j was never selected, all scores are zero
# for each permutation, compute A=RFR and the standardized score
for(b in seq(B)){
A <- R %*% diag(fl[,b]) %*% R
out[b] <- stdScore(X[,j], Y, A)
}
return(out)
}
# EXACT METHOD
resMats <- list()
# for each split, compute and save the terms R=I-H
for(q in seq(Q)){
if(j %in% sel$vars[[q]]){
i <- i+1
resMats[[i]] <- residualMatrix(j, X, sel$obs[[q]], setdiff(sel$vars[[q]],j))
}
}
if(i == 0){return(out)} # if j was never selected, all scores are zero
# for each permutation, compute A=sum(RFR) and the standardized score
for(b in seq(B)){
A <- matrix(0, ncol=n, nrow=n)
for(i in seq_along(resMats)){A <- A + (resMats[[i]] %*% diag(fl[,b]) %*% resMats[[i]])}
out[b] <- stdScore(X[,j], Y, A)
}
return(out)
}
for(j in seq(m)){G[,j] <- jsplitFlip(j, X, Y, sel, fl, exact)}
residualMatrix <- function(j, X, obs, vars){
n <- nrow(X)
R <- matrix(0, ncol=n, nrow=n)
n0 <- length(obs)
intercept <- rep(1, n0)
Xsel <- as.matrix(X[obs, vars])
Z <- cbind(intercept, Xsel)
R[obs,obs] <- diag(n0) - (Z %*% solve(t(Z) %*% Z) %*% t(Z))
return(R)
}
for(j in seq(m)){G[,j] <- jsplitFlip(j, X, Y, sel, fl, exact)}
stdScore <- function(v, Y, A){
effective <- t(v) %*% A %*% Y
variance <- sum((t(v) %*% A)^2)
out <- effective / sqrt(variance)
return(out)
}
for(j in seq(m)){G[,j] <- jsplitFlip(j, X, Y, sel, fl, exact)}
G
summary(G)
summary(as.vector(G))
devtools::document()
devtools::document()
devtools::document()
library(splitFlip)
?simData
res <- simData(m1=2, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
G <- function(X, Y, target=target, seed=42)
)
G <- splitFlip(X, Y, target=target, seed=42)
maxT(G, alpha=0.1)
G <- splitFlip(X, Y, target=target, seed=42)
G <- splitFlip(X, Y, target=target, seed=43)
maxT(G, alpha=0.1)
G <- splitFlip(X, Y, target=target, seed=44)
maxT(G, alpha=0.1)
devtools::document()
library(splitFlip)
?simData
?splitFlip
devtools::document()
library(splitFlip)
?splitFlip
res <- simData(m1=2, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
# standardized scores using the approximate method with Lasso selection of target variables
G1 <- function(X, Y, target=target, seed=42)
# maxT algorithm
maxT(G1, alpha=0.1)
devtools::document()
library(splitFlip)
?splitFlip
es <- simData(m1=2, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
# standardized scores using the approximate method with Lasso selection of target variables
G1 <- splitFlip(X, Y, target=target, seed=42)
# maxT algorithm
maxT(G1, alpha=0.1)
G2 <- splitFlip(X, Y, target=target, varSel=selOracle, varSelArgs=list(toSel=active), seed=42)
# maxT algorithm
maxT(G2, alpha=0.1)
active
G1 <- splitFlip(X, Y, seed=42)
devtools::document()
library(splitFlip)
?splitFlip
res <- simData(m1=2, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
G1 <- splitFlip(X, Y, seed=42)
maxT(G1, alpha=0.1)
G1 <- splitFlip(X, Y, seed=43)
maxT(G1, alpha=0.1)
G1 <- splitFlip(X, Y, target=10)
G1 <- splitFlip(X, Y, target=9)
nrow(X)
ncol(X)
n <- nrow(X)
n
G1 <- splitFlip(X, Y, target=10)
devtools::document()
library(splitFlip)
res <- simData(m1=2, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
# standardized scores using the approximate method with Lasso selection of target variables
G1 <- splitFlip(X, Y, target=target, seed=42)
G1 <- splitFlip(X, Y, target=9, seed=42)
G1 <- splitFlip(X, Y, target=5, seed=42)
G1 <- splitFlip(X, Y, target=6, seed=42)
target <- 6
m <- ncol(X)
n <- nrow(X)
n0 <- floor(n/2)
obs <- vector(mode="list", length=Q)
Q <- 20
obs <- vector(mode="list", length=Q)
vars <- vector(mode="list", length=Q)
q <- 1
tryAgain <- TRUE
h <- 1
# randomly split the data in 2 subsets
D1 <- sample(seq(n), n0) # first subset
V <- do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs)) # selected variables
varSel <- selLasso
varSelArgs <- NULL
V <- do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs)) # selected variables
V
target
V <- do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=8), varSelArgs)) # selected variables
V
V <- do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=10), varSelArgs)) # selected variables
V
V <- do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=20), varSelArgs)) # selected variables
V
