active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
# matrix of standardized scores for all variables (columns) and random sign flips (rows)
# using the approximate method with Lasso selection
G <- splitFlip(X, Y, target=target, seed=42)
# maxT algorithm
maxT(G, alpha=0.1)
# generate linear regression data with 20 variables and 10 observations
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
# matrix of standardized scores for all variables (columns) and random sign flips (rows)
# using the approximate method with Lasso selection
G <- splitFlip(X, Y, target=target, seed=42)
# maxT algorithm
maxT(G, alpha=0.1)
devtools::document()
?splitFlip
# generate linear regression data with 20 variables and 10 observations
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
# matrix of standardized scores for all variables (columns) and random sign flips (rows)
# using the exact method with Lasso selection
G1 <- splitFlip(X, Y, target=target, exact=TRUE, seed=42)
# maxT algorithm
maxT(G1, alpha=0.1)
?maxT
# generate linear regression data with 20 variables and 10 observations
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
# matrix of standardized scores for all variables (columns) and random sign flips (rows)
# using the approximate method with Lasso selection
G <- splitFlip(X, Y, target=target, seed=42)
# maxT algorithm
maxT(G, alpha=0.1)
G2 <- splitFlip(X, Y, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
# maxT algorithm
maxT(G2, alpha=0.1)
G2 <- splitFlip(X, Y, target=target, exact=TRUE, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
# maxT algorithm
maxT(G2, alpha=0.1)
devtools::document()
# generate linear regression data with 20 variables and 10 observations
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
# matrix of standardized scores for all variables (columns) and random sign flips (rows)
# using the exact method with Lasso selection
G1 <- splitFlip(X, Y, target=target, exact=TRUE, seed=42)
# maxT algorithm
maxT(G1, alpha=0.1)
devtools::document()
?splitFlip
# generate linear regression data with 20 variables and 10 observations
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
# matrix of standardized scores for all variables (columns) and random sign flips (rows)
# using the approximate method with Lasso selection
G1 <- splitFlip(X, Y, target=target, seed=42)
# maxT algorithm
maxT(G1, alpha=0.1)
# matrix of standardized scores for all variables (columns) and random sign flips (rows)
# using the exact method with oracle selection
G2 <- splitFlip(X, Y, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
# maxT algorithm
maxT(G2, alpha=0.1)
devtools::document()
?simData
?splitFlip
# generate linear regression data with 20 variables and 10 observations
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
# matrix of standardized scores for all variables (columns) and random sign flips (rows)
# using the approximate method with Lasso selection
G1 <- splitFlip(X, Y, target=target, seed=42)
# maxT algorithm
maxT(G1, alpha=0.1)
G2 <- splitFlip(X, Y, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=3)
# maxT algorithm
maxT(G2, alpha=0.1)
G2 <- splitFlip(X, Y, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=7)
# maxT algorithm
maxT(G2, alpha=0.1)
G2 <- splitFlip(X, Y, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=99)
# maxT algorithm
maxT(G2, alpha=0.1)
library(splitFlip)
remove.packages("splitFlip", lib="~/R/win-library/4.0")
devtools::install_github("annavesely/splitFlip")
?simData
require(splitFlip)
?simData
# generate linear regression data with 20 variables and 10 observations
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
# matrix of standardized scores for all variables (columns) and random sign flips (rows)
# using the approximate method with Lasso selection
G <- splitFlip(X, Y, target=target, seed=42)
# maxT algorithm
maxT(G, alpha=0.1)
#-----------------------------------------------------
setwd("~/Multisplit/Sim_mein")
require(ggplot2)
load("simres_tmp.RData")
library("RColorBrewer")
#cols <- c(brewer.pal(n=6, name = "Blues")[c(3,6)], "darkorange1", "brown3")
#lin <- c("solid", "dashed", "dotdash", "dotted")
myblues <- brewer.pal(n=6, name = "Blues")
cols <- c(myblues[3], "darkorange1", myblues[6], "brown3")
lin <- c("solid", "solid", "dashed", "dotted")
df$pRej <- df$nRej / df$m1
df <- df[df$incrBeta==0,]
df$m1 <- factor(df$m1, levels=c(5,10), labels=c("m1 = 5", "m1 = 10"))
df$SNR <- factor(df$SNR, levels=c(0.25,1,4,16), labels=c("SNR = 0.25", "SNR = 1", "SNR = 4", "SNR = 16"))
x_breaks <- c(0,0.5,0.9)
df0 <- df
df <- df0[df0$m == 100,]
c(min(df$v1), max(df$v1))
c(min(df$nRej), max(df$nRej))
ggplot(data=df, aes(x=rho, y=nRej)) +
geom_line(aes(colour=method, linetype=method), size = 1) +
labs(y = "rejections", x = "rho") +
scale_x_continuous(breaks=x_breaks) +
scale_y_continuous(n.breaks=3) +
facet_grid(SNR ~ m1, scales="free") +
theme_bw(base_size = 15) +
theme(plot.title = element_text(hjust=0.5)) +
scale_colour_manual(values=cols) +
scale_linetype_manual(values=lin)
require(hdi)
?hdi::multi.split
require(splitFlip)
?maxT
maxT
install.packages("BiocManager")
biocManager::install(c("edgeR", "org.EcK12.eg.db"))
BiocManager::install("edgeR")
setwd("~/GitHub/splitFlip")
source("sim_small.R")
setwd("~/GitHub/splitFlip")
require(splitFlip)
?splitFlip
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
target <- 2*length(active)
G1 <- splitFlip(X, Y, target=target, seed=42)
G1
dim(G1)
x <- rnorm(100)
hist(x)
w <- ceiling(0.95*100/2)
w
w <- ceiling((1-0.05/2)*100)
w
k <- sort(x)
sum((x<k[2]) || (x>k[98]))
sum((x<k[2]) | (x>k[98]))
sum(x<k[2])
sum(x>k[98])
x[1]
sum(x<-x[1])
sum(x < -x[1])
x
x <- rnorm(100)
hist(x)
x[1]
sum(x < -abs(x[1]))
sum(x >= abs(x[1]))
sum(x <= -abs(x[1]))
which(x >= abs(x[1]))
which(x <= -abs(x[1]))
k <- abs(x)
sum(k >= k[1])
x <- rnorm(100)
hist(x)
sum(x <= -abs(x[1])) + sum(x >= abs(x[1]))
sum(abs(x) >= abs(x[1]))
x <- rnorm(100)
hist(x)
sum(x <= -abs(x[1])) + sum(x >= abs(x[1]))
sum(abs(x) >= abs(x[1]))
x <- rnorm(100)
hist(x)
sum(x <= -abs(x[1])) + sum(x >= abs(x[1]))
sum(abs(x) >= abs(x[1]))
coeff
cSign
signs
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
target <- 2*length(active)
varSel <- targetOracle()
varSel <- targetOracle
?targetOracle
varSelArgs <- list("toSel"=active)
varSelArgs
m <- ncol(X)
n <- nrow(X)
n0 <- floor(n/2)
obs <- vector(mode="list", length=Q)
Q <- 2
obs <- vector(mode="list", length=Q)
vars <- vector(mode="list", length=Q)
q <- 1
# randomly split the data in 2 subsets
D1 <- sample(seq(n), n0)
obs[[q]] <- setdiff(seq(n), D1)
vars[[q]] <- do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs))
vars
vars[[q]] <- targetOracle(X,Y,target,active)
vars
targetOracle(X,Y,4,c(1,2))
target
active
targetOracle(X,Y,4,c(1,2))
targetOracle(X,Y,4,c(1,2))
vars[[q]] <- targetOracle(X,Y,target,active)
vars
vars[[q]] <- do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs))
vars
vars[[q]] <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs)))
vars
?lm
md <- lm(Y[D1] ~ X[D1, vars[[q]]])
md
md$coefficients
sgn(md$coefficients)
sign(md$coefficients)
sign(md$coefficients[-1])
coeff <- lm(Y[D1] ~ X[D1,vars])$coefficients # fit LM using D1 and selected vars
vars <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs)))
vars[[q]] <- vars
vars[[]]
vars[[q]]
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
varSel <- targetOracle
varSelArgs <- list("toSel"=active)
m <- ncol(X)
n <- nrow(X)
n0 <- floor(n/2)
obs <- vector(mode="list", length=Q)
vars <- vector(mode="list", length=Q)
Q <- 3
obs <- vector(mode="list", length=Q)
vars <- vector(mode="list", length=Q)
cSigns <- rep(0,m) # mode of the estimated coefficients
q <- 1
# randomly split the data in 2 subsets
D1 <- sample(seq(n), n0)
obs[[q]] <- setdiff(seq(n), D1)
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs)))
D1
V
# randomly split the data in 2 subsets
D1 <- sample(seq(n), n0) # first subset
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs))) # selected variables
coeff <- lm(Y[D1] ~ X[D1,V])$coefficients[-1] # coefficients of selected vars
coeff
obs[[q]] <- setdiff(seq(n), D1)
vars[[q]] <- V
coeff >= 0
cSigns[V] + sign(coeff >= 0)
cSigns[V] <- cSigns[V] + sign(coeff >= 0)
obs <- vector(mode="list", length=Q)
vars <- vector(mode="list", length=Q)
cSigns <- rep(0,m) # mode of the estimated coefficients
for(q in seq(Q)){
# randomly split the data in 2 subsets
D1 <- sample(seq(n), n0) # first subset
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs))) # selected variables
coeff <- lm(Y[D1] ~ X[D1,V])$coefficients[-1] # coefficients of selected vars
obs[[q]] <- setdiff(seq(n), D1)
vars[[q]] <- V
cSigns[V] <- cSigns[V] + sign(coeff >= 0)
}
obs <- vector(mode="list", length=Q)
vars <- vector(mode="list", length=Q)
cSigns <- rep(0,m) # mode of the estimated coefficients
for(q in seq(Q)){
# randomly split the data in 2 subsets
D1 <- sample(seq(n), n0) # first subset
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs))) # selected variables
coeff <- lm(Y[D1] ~ X[D1,V])$coefficients[-1] # coefficients of selected vars
obs[[q]] <- setdiff(seq(n), D1)
vars[[q]] <- V
cSigns[V] <- cSigns[V] + sign(coeff)
}
cSigns
obs
vars
cSigns
signs
obs <- vector(mode="list", length=Q)
vars <- vector(mode="list", length=Q)
signs <- rep(0,m) # mode of the estimated coefficients
for(q in seq(Q)){
# randomly split the data in 2 subsets
D1 <- sample(seq(n), n0) # first subset
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs))) # selected variables
coeff <- lm(Y[D1] ~ X[D1,V])$coefficients[-1] # coefficients of selected vars
obs[[q]] <- setdiff(seq(n), D1)
vars[[q]] <- V
signs[V] <- signs[V] + sign(coeff)
}
signs
vars
coeff
obs <- vector(mode="list", length=Q)
vars <- vector(mode="list", length=Q)
signs <- rep(0,m) # mode of the estimated coefficients
for(q in seq(Q)){
# randomly split the data in 2 subsets
D1 <- sample(seq(n), n0) # first subset
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs))) # selected variables
coeff <- lm(Y[D1] ~ X[D1,V])$coefficients[-1] # coefficients of selected vars
obs[[q]] <- setdiff(seq(n), D1)
vars[[q]] <- V
signs[V] <- signs[V] + sign(coeff)
}
signs
signs <- (sign >= 0) + 0
signs <- (signs >= 0) + 0
signs
obs <- vector(mode="list", length=Q)
vars <- vector(mode="list", length=Q)
signs <- rep(0,m) # mode of the estimated coefficients
for(q in seq(Q)){
# randomly split the data in 2 subsets
D1 <- sample(seq(n), n0) # first subset
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs))) # selected variables
coeff <- lm(Y[D1] ~ X[D1,V])$coefficients[-1] # coefficients of selected vars
obs[[q]] <- setdiff(seq(n), D1)
vars[[q]] <- V
signs[V] <- signs[V] + sign(coeff)
}
signs
obs <- vector(mode="list", length=Q)
vars <- vector(mode="list", length=Q)
signs <- rep(0,m) # mode of the estimated coefficients
for(q in seq(Q)){
# randomly split the data in 2 subsets
D1 <- sample(seq(n), n0) # first subset
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs))) # selected variables
coeff <- lm(Y[D1] ~ X[D1,V])$coefficients[-1] # coefficients of selected vars
obs[[q]] <- setdiff(seq(n), D1)
vars[[q]] <- V
signs[V] <- signs[V] + sign(coeff)
}
signs
signs >= 0 + 0
(signs >= 0) + 0
prova <- 2*(signs >= 0) - 1
(signs >= 0) + 0 - prova
prova
(signs >= 0) + 0
for(i in seq_along(prova)){if(prova[i]==-1){prova[i] <- 0}}
prova
(signs >= 0) - prova
devtools::document()
library(splitFlip)
?splitFlip
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
target <- 2*length(active)
G1 <- splitFlip(X, Y, target=target, seed=42)
head(round(G1,2))
maxT(G1, alpha=0.1)
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
# matrix of standardized scores for all variables (columns) and random sign flips (rows)
# using the approximate method with Lasso selection
G1 <- splitFlip(X, Y, target=target, seed=42)
# maxT algorithm
maxT(G1, alpha=0.1)
devtools::document()
devtools::document()
?splitFlip_old
library(splitFlip)
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
G1 <- splitFlip_old(X, Y, target=target, seed=42)
maxT(G1, alpha=0.1)
active
G2 <- splitFlip_old(X, Y, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
devtools::document()
library(splitFlip)
?splitFlips_old
?splitFlip_old
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
# matrix of standardized scores for all variables (columns) and random sign flips (rows)
# using the approximate method with Lasso selection
G1 <- splitFlip_old(X, Y, target=target, seed=42)
maxT(G1, alpha=0.1)
G2 <- splitFlip_old(X, Y, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
maxT(G2, alpha=0.1)
?splitFlip
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
# matrix of standardized scores for all variables (columns) and random sign flips (rows)
# using the approximate method with Lasso selection
G1 <- splitFlip(X, Y, target=target, seed=42)
maxT(G1, alpha=0.1)
G2 <- splitFlip(X, Y, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
# maxT algorithm
maxT(G2, alpha=0.1)
?factor
sign(0)
sign(1)
sign(-1)
sign(-2)
sign(0.1)
setwd("~/GitHub/splitFlip_beta/Simulations_sign/Sim1")
setwd("~/GitHub/splitFlip_beta/Simulations/Sim1")
setwd("~/GitHub/splitFlip_beta/Simulations_sign/Sim1")
devtools::document
devtools::document()
devtools::document()
library(splitFlip)
?splitFlip
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
target <- 2*length(active)
G1 <- splitFlip_old(X, Y, target=target, seed=42)
devtools::document()
library(splitFlip)
?splitFlip
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
# matrix of standardized scores for all variables (columns) and random sign flips (rows)
# using the approximate method with Lasso selection
G1 <- splitFlip(X, Y, target=target, seed=42)
# maxT algorithm
maxT(G1, alpha=0.1)
G2 <- splitFlip(X, Y, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
# maxT algorithm
maxT(G2, alpha=0.1)
?splitFlip
?splitFlip::simData
require(splitFlip)
?splitFlip
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
system.time(G <- splitFlip(X, Y, Q = 50, exact = TRUE, target = target, varSel = targetLasso, seed = 42))
target <- 2*length(active)
system.time(G <- splitFlip(X, Y, Q = 50, exact = TRUE, target = target, varSel = targetLasso, seed = 42))
system.time(G <- splitFlip(X, Y, Q = 50, exact = FALSE, target = target, varSel = targetLasso, seed = 42))
min(G)
maxT(G, alpha = 0.05)
