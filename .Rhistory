G2 <- splitFlip_old(X, Y, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
devtools::document()
library(splitFlip)
?splitFlips_old
?splitFlip_old
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
# matrix of standardized scores for all variables (columns) and random sign flips (rows)
# using the approximate method with Lasso selection
G1 <- splitFlip_old(X, Y, target=target, seed=42)
maxT(G1, alpha=0.1)
G2 <- splitFlip_old(X, Y, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
maxT(G2, alpha=0.1)
?splitFlip
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
# matrix of standardized scores for all variables (columns) and random sign flips (rows)
# using the approximate method with Lasso selection
G1 <- splitFlip(X, Y, target=target, seed=42)
maxT(G1, alpha=0.1)
G2 <- splitFlip(X, Y, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
# maxT algorithm
maxT(G2, alpha=0.1)
?factor
sign(0)
sign(1)
sign(-1)
sign(-2)
sign(0.1)
setwd("~/GitHub/splitFlip_beta/Simulations_sign/Sim1")
setwd("~/GitHub/splitFlip_beta/Simulations/Sim1")
setwd("~/GitHub/splitFlip_beta/Simulations_sign/Sim1")
devtools::document
devtools::document()
devtools::document()
library(splitFlip)
?splitFlip
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
target <- 2*length(active)
G1 <- splitFlip_old(X, Y, target=target, seed=42)
devtools::document()
library(splitFlip)
?splitFlip
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
# matrix of standardized scores for all variables (columns) and random sign flips (rows)
# using the approximate method with Lasso selection
G1 <- splitFlip(X, Y, target=target, seed=42)
# maxT algorithm
maxT(G1, alpha=0.1)
G2 <- splitFlip(X, Y, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
# maxT algorithm
maxT(G2, alpha=0.1)
?splitFlip
?splitFlip::simData
require(splitFlip)
?splitFlip
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
system.time(G <- splitFlip(X, Y, Q = 50, exact = TRUE, target = target, varSel = targetLasso, seed = 42))
target <- 2*length(active)
system.time(G <- splitFlip(X, Y, Q = 50, exact = TRUE, target = target, varSel = targetLasso, seed = 42))
system.time(G <- splitFlip(X, Y, Q = 50, exact = FALSE, target = target, varSel = targetLasso, seed = 42))
min(G)
maxT(G, alpha = 0.05)
?splitFlip
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
res <- splitFlip::simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
res
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
target <- 2*length(active)
o <- splitFlip:::getSplits(X, Y, 1, target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
o
o <- splitFlip:::getSplits(X, Y, 1, target, varSel=splitFlip::targetOracle, varSelArgs=list(toSel=active), seed=42)
o
m <- ncol(X)
n <- nrow(X)
n0 <- floor(n/2)
obs <- vector(mode="list", length=Q)
vars <- vector(mode="list", length=Q)
signs <- matrix(0, ncol=m, nrow=Q)
Q <- 1
m <- ncol(X)
n <- nrow(X)
n0 <- floor(n/2)
obs <- vector(mode="list", length=Q)
vars <- vector(mode="list", length=Q)
signs <- matrix(0, ncol=m, nrow=Q)
q <- q
q <- 1
D1 <- sample(seq(n), n0) # first subset
D1
V <- sort(do.call(varSel, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs))) # selected variables
V <- sort(do.call(splitFlip::targetOracle, args=c(list(X=X[D1,], Y=Y[D1], target=target), varSelArgs=list(toSel=active)))) # selected variables
V <- sort(do.call(splitFlip::targetOracle, args=c(list(X=X[D1,], Y=Y[D1], target=target, toSel=active)))) # selected variables
V
coeff <- lm(Y[D1] ~ X[D1,V])$coefficients[-1]
coeff
sign(coeff)
signs
obs[[q]] <- setdiff(seq(n), D1)
vars[[q]] <- V
signs[q,V] <- sign(coeff)
signs
library(splitFlip)
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
o <- getSplits(X, Y, Q=1, target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
o <- splitFlip::getSplits(X, Y, Q=1, target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
o <- splitFlip:::getSplits(X, Y, Q=1, target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
o
o <- splitFlip:::getSplits(X, Y, Q=2, target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
o
o <- splitFlip:::getSplits(X, Y, Q52, target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
o <- splitFlip:::getSplits(X, Y, Q=5, target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
o
library(splitFlip)
?splitFlip
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
splitFlip:::getSplits(X, Y, Q=1, target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
splitFlip:::getSplits(X, Y, Q=2, target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
splitFlip:::getSplits(X, Y, Q=5, target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
sel <- splitFlip:::getSplits(X, Y, Q=5, target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
sel
sel$signs
j <- 1
sel$signs[,1]
jsign <- sel$signs[,1]
qsel <- which(jsign != 0)
qsel
jsign <- sel$signs[,j] # signs for j for the different splits
jsign
qsel <- which(jsign != 0) # indices of splits that select j
qsel
sel
B <- 10
fl <- cbind(rep(1,n), replicate(B-1, 1-2*rbinom(n,1,0.5)))
n <- nrow(X)
m <- ncol(X)
fl <- cbind(rep(1,n), replicate(B-1, 1-2*rbinom(n,1,0.5)))
fl
library(splitFlip)
?splitFlip
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
# matrix of standardized scores for all variables (columns) and random sign flips (rows)
# using the exact method with oracle selection
G <- splitFlip(X, Y, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
maxT(G, alpha=0.1)
G2 <- splitFlip_new(X, Y, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
library(splitFlip)
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
# matrix of standardized scores for all variables (columns) and random sign flips (rows)
# using the exact method with oracle selection
G <- splitFlip(X, Y, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
maxT(G, alpha=0.1)
G2 <- splitFlip_new(X, Y, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
library(splitFlip)
devtools::document()
library(splitFlip)
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
# matrix of standardized scores for all variables (columns) and random sign flips (rows)
# using the exact method with oracle selection
G <- splitFlip(X, Y, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
maxT(G, alpha=0.1)
G2 <- splitFlip_new(X, Y, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
maxT(G2, alpha=0.1)
library(splitFlip)
library(splitFlip)
#devtools::install_github("annavesely/splitFlip")
require(splitFlip)
analysisG <- function(G, alpha, inactive){
o <- rep(0,2)
tmp <- maxT(G,alpha)$rejected
o[1] <- o[1] + length(tmp)
o[2] <- o[2] + (length(intersect(tmp,inactive))>0)
return(o)
}
get_comparison <- function(m=20, prop=0.1, n=10, alpha=0.1, rho=0.5, SNR=5, nSim=1){
o <- matrix(0, ncol=2, nrow=2)
colnames(o) <- c("nRej", "FWER")
rownames(o) <- c("old", "new")
for(seed in seq(nSim)){
res <- splitFlip::simData(prop=prop, m=m, n=n, rho=rho, type="toeplitz", SNR=SNR, seed=seed)
active <- res$active
inactive <- setdiff(seq(m),active)
target <- 2*length(active)
G <- splitFlip(res$X, res$Y, exact=TRUE, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=seed)
o[1,] <- o[1,] + analysisG(G, alpha, inactive)
G <- splitFlip_new(res$X, res$Y, exact=TRUE, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=seed)
o[2,] <- o[2,] + analysisG(G, alpha, inactive)
}
o <- o/nSim
return(o)
}
# 17 seconds
o <- get_comparison(n=1)
# 17 seconds
o <- get_comparison(n=10)
# 17 seconds
o <- get_comparison(n=10)
o
get_comparison <- function(m=20, prop=0.1, n=10, alpha=0.1, rho=0.5, SNR=5, nSim=10){
o <- matrix(0, ncol=2, nrow=2)
colnames(o) <- c("nRej", "FWER")
rownames(o) <- c("old", "new")
for(seed in seq(nSim)){
res <- splitFlip::simData(prop=prop, m=m, n=n, rho=rho, type="toeplitz", SNR=SNR, seed=seed)
active <- res$active
inactive <- setdiff(seq(m),active)
target <- 2*length(active)
G <- splitFlip(res$X, res$Y, exact=TRUE, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=seed)
o[1,] <- o[1,] + analysisG(G, alpha, inactive)
G <- splitFlip_new(res$X, res$Y, exact=TRUE, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=seed)
o[2,] <- o[2,] + analysisG(G, alpha, inactive)
}
o <- o/nSim
return(o)
}
# 17 seconds
o <- get_comparison(n=10)
# 17 seconds
system.time(o <- get_comparison(n=10))
o
get_comparison <- function(m=20, prop=0.1, n=10, alpha=0.1, rho=0.5, SNR=5, nSim=100){
o <- matrix(0, ncol=2, nrow=2)
colnames(o) <- c("nRej", "FWER")
rownames(o) <- c("old", "new")
for(seed in seq(nSim)){
res <- splitFlip::simData(prop=prop, m=m, n=n, rho=rho, type="toeplitz", SNR=SNR, seed=seed)
active <- res$active
inactive <- setdiff(seq(m),active)
target <- 2*length(active)
G <- splitFlip(res$X, res$Y, exact=TRUE, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=seed)
o[1,] <- o[1,] + analysisG(G, alpha, inactive)
G <- splitFlip_new(res$X, res$Y, exact=TRUE, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=seed)
o[2,] <- o[2,] + analysisG(G, alpha, inactive)
}
o <- o/nSim
return(o)
}
# 17 seconds
system.time(o <- get_comparison(n=10))
o
system.time(o <- get_comparison(n=20, nSim=10))
o
get_comparison <- function(m=20, prop=0.1, n=10, alpha=0.1, rho=0.5, SNR=5, nSim=100){
o <- matrix(0, ncol=2, nrow=2)
colnames(o) <- c("nRej", "FWER")
rownames(o) <- c("old", "new")
for(seed in seq(nSim)){
res <- splitFlip::simData(prop=prop, m=m, n=n, rho=rho, type="toeplitz", SNR=SNR, seed=seed)
active <- res$active
inactive <- setdiff(seq(m),active)
target <- 2*length(active)
#G <- splitFlip(res$X, res$Y, exact=TRUE, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=seed)
#o[1,] <- o[1,] + analysisG(G, alpha, inactive)
G <- splitFlip_new(res$X, res$Y, exact=TRUE, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=seed)
o[2,] <- o[2,] + analysisG(G, alpha, inactive)
}
o <- o/nSim
return(o)
}
system.time(o <- get_comparison(n=20, nSim=10))
o
system.time(o <- get_comparison(n=40, nSim=10))
o
37*10/60
system.time(o <- get_comparison(n=40, nSim=100))
o
system.time(o <- get_comparison(n=20, nSim=100))
o
system.time(o <- get_comparison(n=20, nSim=200))
o
system.time(o <- get_comparison(n=40, nSim=500))
o
0.1 + 2*sqrt(0.1*0.9/500)
X <- rnorm(10)
X <- matrix(rnorm(15), ncol=3)
round(X)
Y <- rnorm(5)
cov(X,Y)
cov(X[,1],Y)
cov(X[,2],Y)
cov(X[,3],Y)
cor(X,Y)
cor(X[,1],Y)
cor(X[,2],Y)
cor(X[,3],Y)
?cor
require(splitFlip)
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
simData0 <- function(prop, m, n, rho=0, type="equicorr", incrBeta=FALSE, SNR=1, seed=NULL){
if(!is.numeric(prop) || !is.finite(prop)){stop("prop must be a number in [0,1]")}
if(prop < 0 || prop > 1){stop("prop must be a number in [0,1]")}
# check on m and n
if(!is.numeric(m) || !is.finite(m) || round(m) <= 0){stop("m must be a positive integer")}
if(!is.numeric(n) || !is.finite(n) || round(n) <= 0){stop("n must be a positive integer")}
m <- round(m)
n <- round(n)
# check on rho, type and SNR
if(!is.numeric(rho) || !is.finite(rho) || rho < -1 || rho > 1){stop("rho must be a number in [-1,1]")}
type <- match.arg(tolower(type), c("equicorr", "toeplitz"))
if(!is.numeric(SNR) || !is.finite(SNR) || SNR <= 0){stop("SNR must be a postive number")}
# check on seed
if(!is.null(seed)){if(!is.numeric(seed) || !is.finite(seed)){stop("seed must be a finite integer")}}
else{seed <- sample(seq(10^9), 1)}
set.seed(round(seed))
if(type == "equicorr"){
X <- sqrt(1-rho) * matrix(rnorm(m*n), ncol=m) + sqrt(rho) * matrix(rep(rnorm(n), m), ncol=m)
}else{
r <- rho^(0:(m-1))
Sigma <- stats::toeplitz(r)
X <- mvtnorm::rmvnorm(n, sigma=Sigma)
}
m1 <- ceiling(m * prop)
active <- seq(m1)
beta <- rep(0,m)
beta[active] <- ifelse(incrBeta, active, rep(1,m1))
mu <- X %*% beta
mu_norm <- sqrt(t(mu) %*% mu)
serr <- mu_norm/SNR # sd of the error term
Y <- rnorm(n=n, mean=mu, sd=serr)
out <- list("X"=X, "Y"=Y, "active"=active)
return(out)
}
res <- simData0(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
res
simData0 <- function(prop, m, n, rho=0, type="equicorr", incrBeta=FALSE, SNR=1, seed=NULL){
if(!is.numeric(prop) || !is.finite(prop)){stop("prop must be a number in [0,1]")}
if(prop < 0 || prop > 1){stop("prop must be a number in [0,1]")}
# check on m and n
if(!is.numeric(m) || !is.finite(m) || round(m) <= 0){stop("m must be a positive integer")}
if(!is.numeric(n) || !is.finite(n) || round(n) <= 0){stop("n must be a positive integer")}
m <- round(m)
n <- round(n)
# check on rho, type and SNR
if(!is.numeric(rho) || !is.finite(rho) || rho < -1 || rho > 1){stop("rho must be a number in [-1,1]")}
type <- match.arg(tolower(type), c("equicorr", "toeplitz"))
if(!is.numeric(SNR) || !is.finite(SNR) || SNR <= 0){stop("SNR must be a postive number")}
# check on seed
if(!is.null(seed)){if(!is.numeric(seed) || !is.finite(seed)){stop("seed must be a finite integer")}}
else{seed <- sample(seq(10^9), 1)}
set.seed(round(seed))
if(type == "equicorr"){
X <- sqrt(1-rho) * matrix(rnorm(m*n), ncol=m) + sqrt(rho) * matrix(rep(rnorm(n), m), ncol=m)
}else{
r <- rho^(0:(m-1))
Sigma <- stats::toeplitz(r)
X <- mvtnorm::rmvnorm(n, sigma=Sigma)
}
m1 <- ceiling(m * prop)
active <- sample(seq(m), m1)
beta <- rep(0, m)
if(incrBeta){
beta[active] <- seq(m1)
}else{
beta[active] <- rep(1,m1)
}
active <- sort(active)
mu <- X %*% beta
mu_norm <- sqrt(t(mu) %*% mu)
serr <- mu_norm/SNR # sd of the error term
Y <- rnorm(n=n, mean=mu, sd=serr)
out <- list("X"=X, "Y"=Y, "active"=active)
return(out)
}
res <- simData0(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
res
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
target <- 2*length(active)
targetLasso(X, Y, target)
active
if(!is.matrix(X) || !is.numeric(X) || !all(is.finite(X))){stop("X must be a matrix of finite numbers")}
if(!is.vector(Y) || !is.numeric(Y) || !all(is.finite(Y))){stop("Y must be a vector of finite numbers")}
if(!(nrow(X)==length(Y))){stop("Dimensions of X and Y are incompatible")}
if(is.null(target)){target <- nrow(X)}
if(!is.numeric(target) || !is.finite(target) || floor(target) <= 0){stop("target must be a positive integer")}
target <- floor(target)
dim(X)
dim(Y)
length(Y)
c <- cor(X,Y)
c
ncol(X)
sort(c, decreasing=FALSE)
sort(c, decreasing=TRUE)
order(c, decreasing=TRUE)
which.max(c)
c <- abs(cor(X,Y))
which.max(c)
order(c, decreasing=TRUE)
c[11]
c[18]
c[3]
sel <- order(c)[seq(target)]
sel
sel <- order(c, decreasing=FALSE)[seq(target)]
sel
sel <- order(c, decreasing=TRUE)[seq(target)]
sel
active
order(c, decreasing=TRUE)
targetLasso(X, Y, target)
sel
c <- cor(X,Y)
order(c, decreasing=TRUE)[seq(target)]
c
devtools::document()
?targetCor
devtools::document()
?targetCor
devtools::document()
library(splitFlip)
?simData
devtools::document()
?simData
devtools::document()
?simData
es <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
# matrix of standardized scores for all variables (columns) and random sign flips (rows)
# using the approximate method with Lasso selection
G <- splitFlip(X, Y, target=target, seed=42)
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
target <- 2*length(active)
# matrix of standardized scores for all variables (columns) and random sign flips (rows)
# using the approximate method with Lasso selection
G <- splitFlip(X, Y, target=target, seed=42)
maxT(G, alpha=0.1)
?splitFlip
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=5, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
# matrix of standardized scores for all variables (columns) and random sign flips (rows)
# using the approximate method with Lasso selection
G1 <- splitFlip(X, Y, target=target, seed=42)
# maxT algorithm
maxT(G1, alpha=0.1)
G2 <- splitFlip(X, Y, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
# maxT algorithm
maxT(G2, alpha=0.1)
res <- simData(prop=0.1, m=20, n=10, rho=0.5, type="toeplitz", SNR=10, seed=42)
X <- res$X # design matrix
Y <- res$Y # response vector
active <- res$active # indices of active variables
# choose target as twice the number of active variables
target <- 2*length(active)
# matrix of standardized scores for all variables (columns) and random sign flips (rows)
# using the approximate method with Lasso selection
G1 <- splitFlip(X, Y, target=target, seed=42)
# maxT algorithm
maxT(G1, alpha=0.1)
G2 <- splitFlip(X, Y, target=target, varSel=targetOracle, varSelArgs=list(toSel=active), seed=42)
# maxT algorithm
maxT(G2, alpha=0.1)
active
